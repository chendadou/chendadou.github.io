{"meta":{"title":"Chen's Blog","subtitle":"","description":"向阳而生。☀️","author":"Chen","url":"https://chendadou.github.io","root":"/"},"pages":[{"title":"tags","date":"2018-08-18T07:38:59.000Z","updated":"2021-04-15T07:08:55.367Z","comments":true,"path":"tags/index.html","permalink":"https://chendadou.github.io/tags/index.html","excerpt":"","text":""},{"title":"About Me","date":"2019-07-30T08:51:51.000Z","updated":"2021-04-15T07:08:55.359Z","comments":true,"path":"about/index.html","permalink":"https://chendadou.github.io/about/index.html","excerpt":"","text":"Chen Dadou 💻 work, 🎸 music github e-mail"}],"posts":[{"title":"关于一些小记录","slug":"record001","date":"2021-04-16T03:30:58.000Z","updated":"2023-03-22T09:08:58.087Z","comments":true,"path":"2021/04/16/record001/","link":"","permalink":"https://chendadou.github.io/2021/04/16/record001/","excerpt":"平时自己瞎折腾的一些小记录。","text":"平时自己瞎折腾的一些小记录。 mac 终端 nvm install v12.10.0 耗时长且安装失败 本机未使用该版本的 node，但每次打开终端总是提示 nvm v12.10.0 还未安装（强迫症受不了这种提示，就试着安装，结果每次安装都是失败）。 解决方式： which node 查找 node 安装目录； 进入该目录，删除 v12.10.0 文件夹（本来该版本也不使用，直接删除也无妨）； 终端不再提示需要安装 v12.10.0 版本的 node。 关于 git 多账户配置（mac）： 取消全局账户配置123456# 查看是否有全局账户git config --global user.name# 若有，取消全局账户配置git config --global --unset user.namegit config --global --unset user.email 生成 ssh key123456789cd ~/.ssh# 生成 ssh keyssh-keygen -t RSA -C &quot;username1@xxx.com&quot;# 设置新的 key 名，默认是 id_rsaEnter file in which to save the key (/Users/&#123;username&#125;/.ssh/id_rsa): id_rsa_test# 同以上步骤，再生成一个 key 名为 id_rsa_me 添加 ssh key12345678ssh-add ~/.ssh/id_rsa_test# 查看 ssh-add 列表，看看是否添加成功ssh-add -l# 在 github 上配置 ssh key，复制 id_rsa_test.pubpbcopy &lt; ~/.ssh/id_rsa_test.pub 修改 config 文件12345678910111213141516# 若没有 config 文件，则新建（在 ~/.ssh/ 目录下）touch config# 编辑 config 文件vim config# config 文件加入以下内容Host githubHostName github.comUser username1IdentityFile ~/.ssh/id_rsa_testHost giteeHostName gitee.comUser username2IdentityFile ~/.ssh/id_rsa_me 测试1234ssh -T git@github.comssh -T git@gitee.com# 如果连接失败，考虑几个因素：是否开了 vpn，是否远程设置了禁止 ssh 关于 hexo 部署时遇到的问题： username.github.io 项目的提交记录里，用户名显示的并非是 github 用户名。该项目提交记录的用户名取决于本机的 git 全局账户配置，即12git config --global user.name &quot;username&quot;git config --global user.email &quot;username@xxx.com&quot; 该项目提交记录的用户名与管理 hexo 初始化项目的用户名无关。 关于 .deploy_gitusername.github.io 项目的 git 提交记录，如果直接删除，将会清除之前的 git 提交记录。","categories":[],"tags":[{"name":"chen","slug":"chen","permalink":"https://chendadou.github.io/tags/chen/"}]},{"title":"关于 Vuex 基础","slug":"vue002","date":"2019-07-28T05:10:22.000Z","updated":"2021-04-16T02:16:39.147Z","comments":true,"path":"2019/07/28/vue002/","link":"","permalink":"https://chendadou.github.io/2019/07/28/vue002/","excerpt":"是什么 Vuex 是一个专门为 Vue.js 应用程序开的状态管理模式； 采用集中式存储管理应用的所有组件状态。 Vuex 组成： state: 数据仓库； getter: 用于获取数据； mutation: 用于修改数据； action: 用于提交 mutation。","text":"是什么 Vuex 是一个专门为 Vue.js 应用程序开的状态管理模式； 采用集中式存储管理应用的所有组件状态。 Vuex 组成： state: 数据仓库； getter: 用于获取数据； mutation: 用于修改数据； action: 用于提交 mutation。 为什么应用场景： 多个视图依赖同一状态； 来自不同视图的行为需要改变同一状态。 怎么用步骤简述 安装 Vuex: 1npm install vuex 或者 1yarn add vuex 创建 Vuex 实例： 12345678new Vuex.Store(&#123; state: &#123; // some state... &#125;, mutations: &#123; // some mutations... &#125;&#125;) main.js =&gt; 将 Vuex 实例挂载到 vue 对象上 代码示例基于 vue-cli 创建的项目。 main.js 123456789101112131415161718192021222324252627282930313233import Vue from \"vue\"import App from \"./App.vue\"import Vuex from \"vuex\"// 设置为 false 以阻止 vue 在启动时生成生产提示Vue.config.productionTip = false// 1. 创建 Vuex 实例Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; countIncrease(state) &#123; state.count++ &#125; /** // 传入第二个参数 countIncrease(state, number) &#123; state.count = number &#125; **/ &#125;&#125;)Vue.prototype.$store = store// 2. 将 Vuex 实例挂载到 vue 对象上new Vue(&#123; store, render: h =&gt; h(App)&#125;).$mount(\"#app\") App.vue 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div id=\"app\"&gt; &lt;h3&gt;count: &#123;&#123; count &#125;&#125;&lt;/h3&gt; &lt;button @click=\"countIncrease\"&gt;点击&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: \"app\", computed: &#123; count() &#123; return this.$store.state.count &#125; &#125;, methods: &#123; countIncrease() &#123; this.$store.commit(\"countIncrease\") /** 传入第二个参数 this.$store.commit(\"countIncrease\", 33) **/ &#125; &#125; &#125;&lt;/script&gt; 原文出处：https://www.imooc.com/learn/1157","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://chendadou.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://chendadou.github.io/tags/vue/"}]},{"title":"关于 Vue 生命周期","slug":"vue001","date":"2019-07-26T11:09:49.000Z","updated":"2021-04-16T07:14:13.342Z","comments":true,"path":"2019/07/26/vue001/","link":"","permalink":"https://chendadou.github.io/2019/07/26/vue001/","excerpt":"总共经历了8个阶段，分别为：创建前/后、挂载前/后、更新前/后、销毁前/后。","text":"总共经历了8个阶段，分别为：创建前/后、挂载前/后、更新前/后、销毁前/后。 vue 生命周期图示 相关代码123456789101112131415161718192021222324252627282930313233343536373839404142434445// version: 2.xnew Vue(&#123; el: '#app', data() &#123; return &#123; message: 'lifecycle' &#125; &#125;, beforeCreate() &#123; console.log('------- 创建前 -------'); console.log(this.$data); // undefined console.log(this.message); // undefined console.log(this.$el); // undefined &#125;, created() &#123; console.log('------- 创建后 -------'); console.log(this.$data); // &#123; message: 'lifecycle' &#125; console.log(this.message); // lifecycle console.log(this.$el); // undefined &#125;, beforeMount() &#123; console.log('------- 挂载前 -------'); console.log(this.$data); // &#123; message: 'lifecycle' &#125; console.log(this.message); // lifecycle console.log(this.$el); // &lt;div id=\"app\"&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; &#125;, mounted() &#123; console.log('------- 挂载后 -------'); console.log(this.$data); // &#123; message: 'lifecycle' &#125; console.log(this.message); // lifecycle console.log(this.$el); // &lt;div id=\"app\"&gt;lifecycle&lt;/div&gt; &#125;, beforeUpdate() &#123; console.log('------- 更新前 -------'); &#125;, updated() &#123; console.log('------- 更新后 -------'); &#125;, beforeDestroy() &#123; console.log('------- 销毁前 -------'); &#125;, destroyed() &#123; console.log('------- 销毁后 -------'); &#125;&#125;) vue 生命周期简述beforeCreatevue 实例的挂载元素 $el 和数据对象 $data 都为 undefined。 createdvue 实例的数据对象 $data 有了，但是挂载元素 $el 还没有。 beforeCreate 和 created由生命周期图示可见，在 beforeCreate 和 created 之间： 判断是否有 el 选项： 有，就继续编译； 没有，就停止编译，也就意味着停止了生命周期，直到在该 vue 实例上调用 vm.$mount(el)。 vm.$mount(el) // el 为挂载的 dom 节点 template 参数选项的有无： 有，将其作为模版编译成 render 函数； 无，将外部 HTML 作为模版编译。 在第 2 条的基础上，作为模版的优先级：render 函数选项 &gt; template 选项 &gt; outer HTML。 beforeMountvue 实例的挂载元素 $el 和数据对象 $data 都初始化了，data.message 还未替换，挂载之前为虚拟 dom 节点。 mountedvue 实例挂载完成，data.message 成功渲染。 beforeUpdate 和 updated当 vue 发现 data 改变时，会触发对应组件重新渲染，先后调用 beforeUpdate 和 updated 钩子函数。 beforeDestroyvue 实例销毁之前调用，在这一步，实例仍然完全可用。 destroyedvue 实例销毁之后调用，说明 vue 实例已移除事件监听以及对 dom 的绑定，所有的子实例也会被销毁。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://chendadou.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://chendadou.github.io/tags/vue/"}]},{"title":"关于 Git 常用命令","slug":"git","date":"2018-11-04T06:42:58.000Z","updated":"2021-04-16T01:43:54.711Z","comments":true,"path":"2018/11/04/git/","link":"","permalink":"https://chendadou.github.io/2018/11/04/git/","excerpt":"设置用户信息1234git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx@xxx&quot;注：有 --global，更改的配置文件位于用户目录下，反之，位于当前项目的 .git/config。","text":"设置用户信息1234git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx@xxx&quot;注：有 --global，更改的配置文件位于用户目录下，反之，位于当前项目的 .git/config。 查看配置信息 123456查看所有：git config --list查看某一项：git config user.namegit config user.email 获取帮助 12git helpgit help config 更新到仓库 1234567891011查看当前文件状态：git status跟踪文件：单个文件 =&gt; git add [file-name]所有文件 =&gt; git add .------ 暂存状态 ------提交更新：git commit -m &quot;提交说明&quot; 分支相关 1234567891011121314查看本地分支和远程分支：git branch git branch -a建立本地分支并推送到远程仓库：git checkout -b [branch-name]git push [remote-name] [branch-name]删除本地分支并推送到远程仓库：git branch -D [branch-name]:[branch-name]git push [remote-name] :[branch-name]推送本地所有分支/tag 到远程仓库：git push origin *:* tag 相关 1234567891011121314查看所有标签：git tag查看某个特定的标签范围(比如v1.5.5)：git tag -l &quot;v1.5.5*&quot;查看标签详情：git show [tag-name]创建标签：git tag -a [tag-name] -m [infomation]推送标签到远程：单个 =&gt; git push [remote-name] [tag-name]多个 =&gt; git push [remote-name] --tags 远程仓库相关 12345678910111213141516远程仓库的名字(remote-name)默认是 origin查看当前远程仓库的名字和对应的urlgit remote -v从远程仓库克隆代码到本地git clone [url]更换远程仓库地址git remote set-url [remote-name] [url]添加远程仓库git remote add [remote-name] [url]从远程仓库抓取数据git fetch [remote-name] 强制 merge 分支 a 并覆盖分支 b 123git fetch --allgit reset --hard [remote-name]/agit push [remote-name] b -f","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://chendadou.github.io/tags/git/"}]},{"title":"Work","slug":"work","date":"2018-10-16T14:08:41.000Z","updated":"2021-04-15T07:08:55.358Z","comments":true,"path":"2018/10/16/work/","link":"","permalink":"https://chendadou.github.io/2018/10/16/work/","excerpt":"关于工作的一些记录2018.10.16 react v16.5.2 生命周期 static getDerivedStateFromProps() 12345678static getDerivedStateFromProps(nextProps, prevState)/** 1. 调用：组件实例化后和接收新属性时将会调用；* 2. 返回一个对象来更新状态，返回 null 表明新属性不需要更新状态；* 3. 调用 this.setState() 通常不会调用该方法。* 注意：父组件导致组件的渲染，即使属性没有更新，该方法也会被调用。* 该方法替换了以往使用的 componentWillReceiveProps(nextProps) 方法。*/","text":"关于工作的一些记录2018.10.16 react v16.5.2 生命周期 static getDerivedStateFromProps() 12345678static getDerivedStateFromProps(nextProps, prevState)/** 1. 调用：组件实例化后和接收新属性时将会调用；* 2. 返回一个对象来更新状态，返回 null 表明新属性不需要更新状态；* 3. 调用 this.setState() 通常不会调用该方法。* 注意：父组件导致组件的渲染，即使属性没有更新，该方法也会被调用。* 该方法替换了以往使用的 componentWillReceiveProps(nextProps) 方法。*/ antd v3.8.4 Modal 对话框1234&lt;Modal destroyOnClose=&#123;true&#125;&gt; &lt;div&gt;content&lt;/div&gt;&lt;/Modal&gt;&lt;!-- destroyOnClose 参数，关闭时销毁 Modal 里的子元素，默认值为 false --&gt; echarts 线形图的 tooltip 中 formatter 自定义123456789101112131415161718192021var tooltip1 = &#123; trigger: 'axis', formatter: '&#123;a&#125;&lt;br&gt;&#123;b&#125;&lt;br&gt;&#123;c&#125;'&#125;var tooltip2 = &#123; trigger: 'axis', formatter: function(params)&#123; var str = params[0].axisValueLabel + '&lt;br&gt;'; for(var i=0; i&lt;params.length; i++)&#123; str+=params[i].marker + params[i].value + ' 自定义文字' &#125; return str; &#125;&#125;/** 1. trigger: axis（坐标轴触发），item（数据项图形）；* 2. formatter 自定义：* (1) 字符串，缺点是没有了原有的对应的标识（marker）；* (2) 回调函数：有效解决了字符串存在的问题。 **/ 2018.10.17 socket.io-client 问题：在某个组件内的 componentDidMount() 方法中使用，卸载时没有进行监听事件的移除，导致一直在监听事件。 解决方式：期望只在该组件中监听事件，当组件移除时取消通讯。1234567891011121314151617export default class Demo extends React.Component &#123; constructor() &#123; this.socketObj = io('http://www.xxx.com/socket'); &#125; componentDidMount = () =&gt; &#123; this.socketObj.emit('getData'); this.socketObj.on('getData', (e)=&gt;&#123; console.log('getData', e); &#125;); &#125; componentWillUnmount = () =&gt; &#123; // 移除监听事件 this.socketObj.removeListener('getData'); // this.socketObj.close()，关闭连接。 // 但之后再次进入该组件时，每一次挂载操作会增加新的监听事件，导致事件数量一直增加。所以选择移除事件。 &#125;&#125; 2018.10.1812345678910let json1 = &#123; a: 1, b: 2, c: 3 &#125;;let json2 = &#123; a: 2 &#125;;let json3 = Object.assign(&#123;&#125;, json1, json2);console.log(json3); // &#123; a: 2, b: 2, c: 3 &#125;// 等价于以下的代码let json4 = &#123; a: 1, b: 2, c: 3 &#125;;let json5 = &#123; a: 2 &#125;;let json6 = &#123;...json4, ...json5&#125;;console.log(json6); // &#123; a: 2, b: 2, c: 3 &#125; 2018.12.28input 缓存问题（自动填充） 问题：input 输入框会自动填充已存入浏览器的表单数据，主要表现在密码输入框。 解决方式：1234567891011&lt;!-- 1. type = 'text' --&gt;&lt;form autocomplete='off'&gt; &lt;input type='text' /&gt;&lt;/form&gt;&lt;!-- 2. type = 'password' --&gt;&lt;input type='password' style='display: none;' /&gt;&lt;input type='password' /&gt;&lt;!-- 或者 --&gt;&lt;input type='password' aotocomplete='new-password' /&gt;&lt;!-- 附注：autocomplete='off' 和 autocomplete='new-password' 的 input 属性设置在 firefox 下可能无效。 --&gt; 2019.02.01Element.scrollIntoView() 方法官方解释：让当前的元素滚动到浏览器窗口的可视范围内。支持两种参数传入方式： element.scrollIntoView(alignToTop:Boolean);当传入 true，等价于 element.scrollIntoView(); true: 元素顶端与所在滚动区的可视区域的顶端对齐； false: 元素顶端与所在滚动区的可视区域的底端对齐。 element.scrollIntoView(scrollIntoViewOptions: Object);IE 不支持。123456789101112var element = document.getElementById('box');element.scrollIntoView();element.scrollIntoView(false);element.scrollIntoView(&#123;block: 'end'&#125;);element.scrollIntoView(&#123;behavior: 'instant', block: 'end', inline: 'nearest'&#125;);/* 1. behavior: 动画效果，默认值 auto，可选值有 auto, instant, smooth； 2. block: 默认值 center, 可选值有 start, end, center, nearest； 3. inline: 默认值 nearest, 可选值与 block 的可选值一致。*/","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://chendadou.github.io/tags/notes/"}]},{"title":"XSS and CSRF","slug":"xssandcsrf","date":"2018-08-18T08:03:14.000Z","updated":"2021-04-16T07:14:04.606Z","comments":true,"path":"2018/08/18/xssandcsrf/","link":"","permalink":"https://chendadou.github.io/2018/08/18/xssandcsrf/","excerpt":"XSSXSS（Cross Site Scripting），跨站脚本攻击。 反射型 XSS诱导用户自己点开链接（一次性）。","text":"XSSXSS（Cross Site Scripting），跨站脚本攻击。 反射型 XSS诱导用户自己点开链接（一次性）。 eg. 用户登录成功后，当在链接中注入脚本时，即 1// http://www.xxx.com?content=&lt;script&gt;alert(document.cookie)&lt;/script&gt; chrome 发现路径异常，会有 xss 屏蔽功能； firefox 则会运行 alert(document.cookie)，若服务端将 SESSION_ID 这样的身份认证字段存在 cookie 内，则用户会有信息暴露的危险； 解决方式如下： 一般情况下让 cookie 在前端无法获取，即服务端存入 cookie 时设置 httpOnly: true。该方式仅降低受损范围，不推荐； 查询参数时，加上 encodeURIComponent(query.content) 来解决。 DOM-Based 不基于后端：修改属性，插入内容，document.write… 该攻击只改变当前客户端的页面结构； 攻击的内容：xss payload； 解决方式：转义输入的内容，encodeURI()。 12345678910/* * eg. 输入url，获取输入内容并显示图片 * 攻击有以下两种情况 * &lt;img src=\"xxx\" onerror=\"alert(1)\" /&gt; * &lt;img src=\"&lt;script&gt;alert(1)&lt;/script&gt;\" /&gt;*/$('#add').on('click', function() &#123; $('.box').html(`&lt;img src=\"$&#123;encodeURI($('#web').val())&#125;\" /&gt;`)&#125;) 存储型 XSS恶意的脚本存储到了服务器上，所有人访问时都会受到攻击，比以上两种攻击方式受到的攻击范围更大。eg. 个人登录后在评论区发表评论，评论内容为恶意脚本。 解决方式如下： 客户端传递给服务器时，需要校验过滤； 服务端再做一次过滤； 直接在输出的时候过滤。 123456789// 过滤function encodeHtml(str) &#123; return str.replace(/&amp;/g, '&amp;amp;'). replace(/\\\"/g, '&amp;quot;'). replace(/\\'/g, '$apos;'). replace(/&lt;/g, '&amp;lt;'). replace(/&gt;/g, '&amp;gt;')&#125; CSRFCSRF（Cross-site request forgery），跨站请求伪造。eg. 如下图所示 图例几点说明： form 表单提交是没有跨域问题的； 第三方网站拿不到用户 cookie，当往 4000 端口提交内容时会自动提交 cookie。 解决方法如下： 添加验证码（体验不好） 判断来源，请求头Referer（不靠谱，可通过 node 自己发请求来实现伪造） token （推荐）","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://chendadou.github.io/tags/notes/"}]},{"title":"Collections","slug":"collections","date":"2018-07-13T05:41:52.000Z","updated":"2021-04-16T05:21:50.917Z","comments":true,"path":"2018/07/13/collections/","link":"","permalink":"https://chendadou.github.io/2018/07/13/collections/","excerpt":"http://www.bootcdn.cn/ 前端开源项目 CDN 加速服务 https://github.com/ProtoTeam/blog/blob/master/201805/3.md 如何阅读大型前端开源项目的源码","text":"http://www.bootcdn.cn/ 前端开源项目 CDN 加速服务 https://github.com/ProtoTeam/blog/blob/master/201805/3.md 如何阅读大型前端开源项目的源码 https://www.npmjs.com/ npm is the package manager for JavaScript and the world’s largest software registry http://sangka-z.com/react-in-patterns-cn/ React 模式 http://www.ruanyifeng.com/blog/2016/06/css_modules.html CSS Modules 用法教程 https://caniuse.com/ 前端兼容性自查工具 https://cn.vuejs.org/ Vue.js https://reactjs.org/ React.js https://www.webpackjs.com/ Webpack，静态模块打包器 https://jsonlint.com/JSON 校验与转换 http://nodejs.cn/Node.js http://www.expressjs.com.cn/Express，基于 Node.js 平台的 web 开发框架 https://yarn.bootcss.com/Yarn，依赖管理工具 https://koa.bootcss.com/Koa，基于 Node.js 平台的下一代 web 开发框架 https://www.babeljs.cn/Babel，Javascript 编译器 https://react-guide.github.io/react-router-cn/React Router 中文文档 https://www.redux.org.cn/React Redux 中文文档 https://reactnative.cn/React Native https://www.tslang.cn/Typescript https://vuex.vuejs.org/Vuex https://pro.ant.design/index-cnant-design-pro, 开箱即用的中台前端/设计解决方案 https://panjiachen.github.io/vue-element-admin-site/zh/vue-element-admin https://wangdoc.com/ssh/index.htmlSSH 教程","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://chendadou.github.io/tags/notes/"}]},{"title":"关于 HTTP 基础","slug":"http","date":"2018-06-19T10:00:06.000Z","updated":"2021-04-16T07:13:59.152Z","comments":true,"path":"2018/06/19/http/","link":"","permalink":"https://chendadou.github.io/2018/06/19/http/","excerpt":"HTTP 的三次握手三次握手创建一个TCP连接的过程。","text":"HTTP 的三次握手三次握手创建一个TCP连接的过程。 为什么要进行三次握手？为了规避因网络传输延时而导致的一些服务器开销的问题。 URI、URL、URNURI统一资源标志符（Uniform Resource Identifier）。用来标识互联网上的唯一资源，包括URL和URN。 URL统一资源定位器（Uniform Resource Locator）。用来找到资源所在的位置并进行寻找和访问。 protocol://user:pass@host.com:port/path?query=string#hash URN永久统一资源定位符。在资源移动之后还能被找到。 HTTP报文 HTTP方法用来定义对于资源的操作。常用的有GET、POST等。从定义上讲有各自的语义。 HTTP CODE定义服务器对请求的处理结果。各个区间的CODE有各自的语义。好的HTTP服务可以通过CODE判断结果。 HTTP Header 缓存头 Cache-Control max-age； no-cache 经过服务器端缓存验证是否可以使用缓存； no-store 不考虑缓存。 缓存验证 Last-Modified 和 Etag Last-Modified 上次修改时间，配合 If-Modified-Since 使用； Etag 数据签名，配合 If-Match 和 If-None-Match 使用。 cookie 含义： 通过 Set-Cookie 这个 HTTP Header 设置的保存在浏览器中的内容； 下次请求会自动带上； 键值对，并且可设置多个。 属性： max-age（s） 和 expires； Secure （https）； HttpOnly，无法通过 document.cookie 访问（考虑到安全性）； domain。 Connection Keep-Alive 保持长链接； Chrome 最多允许6个并发请求。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"https://chendadou.github.io/tags/http/"}]},{"title":"关于 Hexo 搜索功能","slug":"hexo001","date":"2017-06-02T06:40:23.000Z","updated":"2021-04-16T07:13:54.960Z","comments":true,"path":"2017/06/02/hexo001/","link":"","permalink":"https://chendadou.github.io/2017/06/02/hexo001/","excerpt":"设置步骤 下载 hexo-generator-searchdb 插件1npm install hexo-generator-searchdb --save","text":"设置步骤 下载 hexo-generator-searchdb 插件1npm install hexo-generator-searchdb --save 修改站点配置your_blog/.config.yml 12345search: path: search.xml field: post format: html limit: 10000 修改主题配置your_blog/themes/your_theme/.config.yml 123# 找到 local_search，将 enable 的值设置为 truelocal_search: enable: true 出现的问题及解决方式搜索功能无效 原因1: 搜索插件配置问题按照以上所示设置步骤设置一下即可。 原因2: md 文档含有特殊字符 界面显示：点击搜索后，只出现 loading 状态，搜索无法加载出来。 调试：地址栏输入 http://localhost:4000/search.xml页面输出以下内容： 查看 network，请求正常且返回了 200：注：也有返回 304 的情况，我这边是返回了 200。 解决方式：全局使用正则表达式搜索 \\x08 或者 \\u0008，搜索到到内容替换成空格。注：也可能是其他的特殊字符，搜索替换为空就行。","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"https://chendadou.github.io/tags/notes/"}]},{"title":"关于 Javascript 的 this 和闭包","slug":"js001","date":"2017-05-20T07:32:54.000Z","updated":"2021-04-15T07:08:55.356Z","comments":true,"path":"2017/05/20/js001/","link":"","permalink":"https://chendadou.github.io/2017/05/20/js001/","excerpt":"this 是 Javascript 中的一个关键字； 对闭包的理解： 能够读取其他函数内部变量的函数； 定义在一个函数内部的函数； 本质上来说，闭包就是将函数内部和函数外部连接起来的一座桥梁。","text":"this 是 Javascript 中的一个关键字； 对闭包的理解： 能够读取其他函数内部变量的函数； 定义在一个函数内部的函数； 本质上来说，闭包就是将函数内部和函数外部连接起来的一座桥梁。 关于 this纯粹的函数调用 1234567var x = 1;function test() &#123; console.log(this.x);&#125;test(); // 1// 全局调用，故 this 指向全局对象。 作为对象方法的调用 1234567891011function test() &#123; console.log(this.x);&#125;var obj = &#123;&#125;;obj.x = 1;obj.m = test;obj.m(); // 1// 作为 obj 对象方法的调用，故 this 指向 obj 对象，即上级对象。 作为构造函数的调用 12345678910111213var x = 2;function test() &#123; this.x = 1;&#125;var obj = new test();console.log(obj.x); // 1console.log(x); // 2/** 1. 构造函数：通过这个函数（test），可以生成一个新对象（obj）； 2. 这边的 this 指向这个新对象。**/ apply() / call() 1234567891011121314151617181920var x = 0;function test() &#123; console.log(this.x);&#125;var obj = &#123;&#125;;obj.x = 1;obj.m = test;obj.m.apply(); // 0obj.m.apply(obj); // 1/** apply(): 1. 是函数的一个方法，作用为改变函数的调用对象； 2. 第一个参数就表示改变后的调用这个函数的对象，这边 this 就是第一个参数； 3. 当第一个参数为空时，默认调用全局对象。 call() 同理。**/ 箭头函数中的 this 123456789101112131415const obj = &#123; a: function() &#123; setTimeout(function () &#123; console.log(this); // 指向 window 对象 &#125;, 1000); &#125;, b: function() &#123; setTimeout(() =&gt; &#123; console.log(this); // 指向 obj 对象 &#125;, 2000); &#125;&#125;obj.a();obj.b();// 箭头函数中的 this 指向 定义时 所在的对象。 关于闭包闭包用途 可以读取函数内部的变量； 让变量的值始终保持在内存中。 示例 123456789101112131415function f1() &#123; var n = 999; nAdd = function () &#123; n += 1; &#125; function f2() &#123; console.log(n); &#125; return f2;&#125;var result = f1();result(); // 999nAdd();result(); // 1000 注意 不能滥用闭包，否则易导致网页出现性能问题，可能导致内存泄漏等。解决方法为：在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部改变父函数内部变量的值。 最后要说代码片段一 123456789101112131415var name = \"The Window\";var object = &#123; name: \"My Object\", getNameFunc: function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()); // The Window/** object.getnameFunc() 返回的匿名闭包函数被全局变量所引用，其中的this指向 全局变量，当执行时打印 The Window。**/ 代码片段二 1234567891011121314151617var name = \"The Window\";var object = &#123; name: \"My Object\", getNameFunc: function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()); // My Object/** object.getnameFunc() 在返回闭包函数前，将 this 赋给 that，此时 getnameFunc 是由 object 调用的，故而 this 指向 object，当内部函数被返回时，由于闭包的特性，仍然 能访问到外部函数中的值，当执行打印 My Object 。**/ 参考：http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.htmlhttp://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://chendadou.github.io/tags/javascript/"}]}],"categories":[],"tags":[{"name":"chen","slug":"chen","permalink":"https://chendadou.github.io/tags/chen/"},{"name":"javascript","slug":"javascript","permalink":"https://chendadou.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://chendadou.github.io/tags/vue/"},{"name":"git","slug":"git","permalink":"https://chendadou.github.io/tags/git/"},{"name":"notes","slug":"notes","permalink":"https://chendadou.github.io/tags/notes/"},{"name":"http","slug":"http","permalink":"https://chendadou.github.io/tags/http/"}]}